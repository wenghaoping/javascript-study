<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- <link href="https://fonts.font.im/css?family=Do+Hyeon" rel="stylesheet"> -->
    <style>
       *{
           margin: 0;
           padding: 0;
           box-sizing: border-box;
       }
       body{
           height: 100vh;
           display: flex;
           align-items: center;
           justify-content: center;
           background-color: rgb(243, 239, 8);
       }
       .anniu,.anniu::after{
           font-family: 'Do Hyeon', sans-serif;
           width: 260px;
           height: 80px;
           text-align: center;
           font-size: 22px;
           line-height: 80px;
           color: rgb(255, 251, 251);
           background: linear-gradient(30deg,transparent 10%,rgb(255, 136, 0) 10% 95%,  rgb(0, 255, 149) 95%);
           box-shadow: 5px 0 0 rgb(0, 204, 255);
           cursor: pointer;
           position: relative;
       }
       .anniu::after{
           content: 'Aurora Borealis night';
           position: absolute;
           top: 0;
           left: 0;
           text-shadow: -5px -2px 0 rgb(0, 183, 255),
           5px 2px 0 rgb(0, 255, 115) ;
           visibility: hidden;
          
       } 
       .anniu:hover::after{
           animation: san 1s ; 
           animation-timing-function: steps(1, end);
       }

       /* 
       
       clip-path: inset(20% -5px  60%  0);
       clip-path: inset(50% -5px  30%  0);
       clip-path: inset(80% -5px  5%  0);
       clip-path: inset(0 -5px  80%  0);
       
       
        */
       @keyframes san{
           0%{
            clip-path: inset(20% -5px  60%  0);
            transform: translate(-6px,5px);
            visibility: visible;
           }
           10%{
            clip-path: inset(50% -5px  30%  0);
            transform: translate(6px,-5px);
           }
           20%{
            clip-path: inset(20% -5px  60%  0);
            transform: translate(5px,0px);

            }
            30%{
                clip-path: inset(80% -5px  5%  0);
            transform: translate(-8px,5px);
            }
            40%{
                clip-path: inset(0 -5px  80%  0);
            transform: translate(-4px,-3px);

            }
            50%{
                clip-path: inset(50% -5px  30%  0);
            transform: translate(-6px,-5px);
            }
            60%{
                clip-path: inset(80% -5px  5%  0);
            transform: translate(-7px,5px);

            }
            70%{
                clip-path: inset(0 -5px  80%  0);
            transform: translate(3px,6px);
            }
            80%{
                clip-path: inset(50% -5px  30%  0);
            transform: translate(5px,5px);

            }
            90%{
                clip-path: inset(20% -5px  60%  0);
            transform: translate(6px,-5px);

            }
            100%{
                clip-path: inset(0 -5px  80%  0);
            transform: translate(1px,5px);

            }
       }
    </style>
</head>
<script>
    // on(event, listener)：为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。
// emit(event, [arg1], [arg2])： 按监听器的顺序执行执行每个监听器
// addListener(event, listener)：on的同名函数（alias）
// once(event, listener): 和on类似，但只触发一次，随后便解除事件监听
// removeListener(event, listener)： 移除指定事件的某个监听回调
// removeAllListeners([event])：移除指定事件的所有监听回调
// setMaxListeners(n)：用于提高监听器的默认限制的数量。（默认10监听回调个产生警告）
// listeners(event)： 返回指定事件的监听器数组。
class EventBus {
  constructor() {
    this._events = {};
  }
  // 注册事件和处理函数
  on(type, fn) {
    if (Array.isArray(type)) {
      for (let i = 0; i < type.length; i++) {
        const e = type[i];
        this.on(e, fn);
      }
    } else {
      const event = this._events[type];
      // 存在直接push, 不存在创建为空数组再push
      if (event) {
        event.push(fn);
      } else {
        this._events[type] = [fn];
      }
    }
    console.log(this._events, "_events");
  }
  // 注册事件和处理函数，触发一次后销毁
  once(type, fn) {
    if (Array.isArray(type)) {
      for (let i = 0; i < type.length; i++) {
        const e = type[i];
        this.once(e, fn);
      }
    } else {
      const self = this;
      function hander() {
        self.off(type, fn);
        //emit里面调用时会给on方法传参
        fn.apply(this, arguments);
      }
      hander.fn = fn; //off里面根据这个判断销毁事件
      this.on(type, hander);
    }
  }
  // 触发某事件所有回调并带参数
  emit(type, ...ars) {
    if (Array.isArray(type)) {
      for (let i = 0; i < type.length; i++) {
        const e = type[i];
        this.emit(e);
      }
    } else {
      const events = this._events[type];
      if (events) {
        for (let i = 0; i < events.length; i++) {
          const e = events[i];
          e.apply(this, ars);
        }
      }
    }
  }
  // 销毁事件和处理函数
  off(type, fn) {
    //不传参数表示清空所有
    if (!type) {
      this._events = [];
    }
    //数组循环清空
    if (Array.isArray(type)) {
      type.forEach((e) => {
        this.off(e, fn);
      });
    } else {
      //不传第二参表示清空某事件所有监听函数
      if (!fn) {
        this._events[type] = [];
      }
      const events = this._events[type];
      let index = events.findIndex((f) => f === fn);
      while (index !== -1) {
        events.splice(index, 1);
        index = events.findIndex((f) => f === fn);
      }
    }
    console.log(this._events, "_events");
  }
}

//测试用例
let eb = new EventBus();
eb.once("event1", (params) => console.log(11, params));
eb.on("event2", (params) => console.log(22, params));
eb.emit("event1", 33);
eb.emit("event2", 33);

</script>
<body>
    <div class="anniu">Aurora Borealis night</div>
</body>
</html>
